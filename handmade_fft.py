# БЛОК 1. Подключение всех модулей.

import numpy as np # массивы, вычисления, fft, ifft для сравнения
import time # измерение времени для оценки быстродействия

# БЛОК 2. Класс, отвечающий за вычисление БПФ.

class FFT:
    
    @staticmethod
    def dft_method(x_list):
    
        '''
        Функция, реализующая метод прямого медленного ДПФ;
        На вход: комплексный x_list - входной массив (временные отсчеты);
        На выходе: комплексный массив y_list (спектр)
        '''

        N = len(x_list) # длина выборки отсчетов
        y_list = np.zeros((N),dtype=complex) # заготовка под будущий спектр

        for (n,x) in enumerate(x_list):
            y_list[n] = x_list.dot(np.exp(-1j*2*np.pi*n*np.arange(N)/N)) # формула прямого ДПФ

        return np.array(y_list)
    
    @staticmethod
    def dft(x_list):
    
        '''
        Функция, осуществляющая прямое медленное ДПФ для всего спектра;
        На вход: комплексный x_list - входной массив (временные отсчеты);
        На выходе: комплексный массив y_list (спектр)
        '''

        return FFT.dft_method(x_list)
    
    @staticmethod
    def idft(y_list):

        '''
        Функция, осуществляющая обратное медленное ДПФ для всего спектра;
        На вход: комплексный y_list - входной массив (спектр);
        На выходе: комплексный массив x_list (временные отсчеты)
        '''

        # обратное ДПФ отличается от прямого двукратным сопряжением (входных и выходных данных),
        # нормировкой на число членов

        return FFT.dft_method(y_list.conjugate()).conjugate()/len(y_list)
    
    @staticmethod
    def fft_method(x_list):

        '''
        Функция, реализующая метод прямого быстрого ДПФ;
        На вход: комплексный x_list - входной массив (временные отсчеты);
        На выходе: комплексный массив y_list (спектр)
        '''

        N = len(x_list) # длина выборки отсчетов

        if N==1: # если длина выборки равна 1, ДПФ - это сам элемент
            return x_list

        # рассмотрим отдельно случаи кратности каждому из простых множителей

        if N%2==0: # случай кратности двум

            w = np.exp(-1j*2*np.pi*np.arange(N//2)/N) # веса в формуле
            f = np.exp(-1j*np.pi) # множитель "поворота"

            # вычислим ДПФ, меньшие по размеру выборки в два раза, запустив рекурсию

            y_1 = FFT.fft(x_list[0:N:2])
            y_2 = FFT.fft(x_list[1:N:2])*w

            # здесь и далее: матрица коэффициентов "поворота" имеет вид
            # m_ij = f**(i*j), где i,j - номера строки, столбца

            return np.hstack((y_1+y_2, y_1+f*y_2))

        if N%3==0: # случай кратности трем

            w = np.exp(-1j*2*np.pi*np.arange(N//3)/N) # веса в формуле
            f = np.exp(-1j*2*np.pi/3) # множитель "поворота"

            # вычислим ДПФ, меньшие по размеру выборки в три раза, запустив рекурсию

            y_1 = FFT.fft(x_list[0:N:3])
            y_2 = FFT.fft(x_list[1:N:3])*w
            y_3 = FFT.fft(x_list[2:N:3])*w**2

            return np.hstack((y_1+y_2+y_3, y_1+y_2*f+y_3*f**2, y_1+y_2*f**2+y_3*f**4))

        if N%5==0: # случай кратности пяти

            w = np.exp(-1j*2*np.pi*np.arange(N//5)/N) # веса в формуле
            f = np.exp(-1j*2*np.pi/5) # множитель "поворота"

            # вычислим ДПФ, меньшие по размеру выборки в пять раз, запустив рекурсию

            y_1 = FFT.fft(x_list[0:N:5])
            y_2 = FFT.fft(x_list[1:N:5])*w
            y_3 = FFT.fft(x_list[2:N:5])*w**2
            y_4 = FFT.fft(x_list[3:N:5])*w**3
            y_5 = FFT.fft(x_list[4:N:5])*w**4


            return np.hstack((y_1+y_2+y_3+y_4+y_5, 
                              y_1+y_2*f+y_3*f**2+y_4*f**3+y_5*f**4,
                              y_1+y_2*f**2+y_3*f**4+y_4*f**6+y_5*f**8,
                              y_1+y_2*f**3+y_3*f**6+y_4*f**9+y_5*f**12,
                              y_1+y_2*f**4+y_3*f**8+y_4*f**12+y_5*f**16
                             ))    
    
    @staticmethod
    def fft(x_list):

        '''
        Функция, осуществляющая прямое быстрое ДПФ для всего спектра;
        На вход: комплексный x_list - входной массив (временные отсчеты);
        На выходе: комплексный массив y_list (спектр)
        '''

        return FFT.fft_method(x_list)
    
    @staticmethod
    def ifft(x_list):

        '''
        Функция, осуществляющая обратное медленное ДПФ для всего спектра;
        На вход: комплексный y_list - входной массив (спектр);
        На выходе: комплексный массив x_list (временные отсчеты)
        '''

        # обратное ДПФ отличается от прямого двукратным сопряжением (входных и выходных данных),
        # нормировкой на число членов

        return FFT.fft_method(x_list.conjugate()).conjugate()/len(x_list)
    
# БЛОК 3. Вспомогательные функции для проверки быстродействия алгоритмов.

def time_tester(method, N_list):
    
    '''
    Функция, строящая зависимость времени расчета ДПФ от размера выборки;
    На вход: method - алгоритм выполнения ДПФ;
             N_list - целочисленный список всех значений N;
    На выходе: t_list - вещественный массив времен расчета для разных N
    '''
    
    t_list = np.zeros(len(N_list))
    
    for n in range(len(N_list)):
        t_0 = time.time()
        x_list = np.random.uniform(-1, 1, N_list[n]) + 1j * np.random.uniform(-1, 1, N_list[n])
        method(x_list)
        dt = time.time() - t_0
        t_list[n] = dt
        
    return t_list

def sample_235(N):
    
    '''
    Функция, возвращающая выборку длины 2^((N-1)*3) вида 2^p_1*3^p_2*5^p_3;
    На вход: целое число N - максимальная степень в формуле;  
    На выходе: sample - массив целых значений, рассчитанных по формуле 2^p_1*3^p_2*5^p_3,
    где p_n пробегают все значения от 0 до N-1
    '''
    
    sample = [2**i*3**j*5**k for i in range(N) for j in range(N) for k in range(N)] # формула элементов выборки
    
    return np.array(sample)